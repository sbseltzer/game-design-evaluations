# What is this?

An exercise taken from [Jeff Vogel's Blog](http://jeff-vogel.blogspot.com/2016/09/a-very-long-post-about-how-to-become.html).
> Exercise #2:
>
>Think back to the last 3 (or more) games you played for more than ten minutes. For each one, come up with a list of three SPECIFIC things it did well, and three things it did badly. Then come up with one design element you can see yourself wanting to use in a game of your own.
>
>You should be able to do this for any game. Every game has problems or rough spots, and I've never played for 10+ minutes a game so bad it had nothing to offer (even if it's just a cool little animation on the title screen).

Thanks Jeff!

This is a repository of game design evaluations. I plan to do these as frequently as possible. I have a massive Steam library of games I've never installed which were likely acquired through bundles. This is a great opportunity to explore games/genres I've never cared for in a new light. I think those may be the most insightful ones to evaluate.

This is the format for each game.
```
# Title
Brief description

## Good
Three SPECIFIC things it did well
1. A
2. B
3. C

## Bad
Three things it did badly
1. A
2. B
3. C

## Steal
One design element
```

# Why?

I saw Jeff Vogel at GDC 2018 and his presentation inspired me to redirect my focus at honing my design skills. I was already yearning to be a creator of games again instead of shooting solely for being a game programmer, though that is still an important goal for me. Early on in life I spent a lot of time playing, imagining, experimenting, and prototyping before I even knew what that was. Doubling down on programming for years and allowing my creative skills to slip is one of my greatest regrets. Turns out aiming to be a good programmer and/or studying computer science does not make you a good *game programmer*. That is, the actual programming of the *game* part. Learning to sequence events in your designs and actually MAKING GAMES makes you a good game programmer. I got pretty good at tools and some engine features, but it's an entirely different skillset and I think it requires one to have some strong design skills to put everything into context. This is a distinction I didn't make until quite recently and it's frustrating that it took so long. This topic deserves a blog post of its own, but I think I've covered the important parts already.
